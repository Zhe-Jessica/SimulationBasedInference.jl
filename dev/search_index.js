var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"Index of full API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [SimulationBasedInference]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/#SimulationBasedInference.EKS","page":"API Reference","title":"SimulationBasedInference.EKS","text":"EKS <: EnsembleInferenceAlgorithm\n\nRepresents a proxy for the Ensemble Kalman Sampler implementation provided by EnsembleKalmanProcesses.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.EmpiricalGaussian","page":"API Reference","title":"SimulationBasedInference.EmpiricalGaussian","text":"EmpiricalGaussian <: GaussianApproximationMethod\n\nRepresents a simple Gaussian approximation method which calculates a sample mean and covariance.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.EnIS","page":"API Reference","title":"SimulationBasedInference.EnIS","text":"EnIS\n\nBasic ensemble importance sampling (EnIS) inference algorithm. Also sometimes referred to as a \"particle batch smoother\" (PBS) or \"generalized likelihood uncertainty estimation\" (GLUE) depending on the context.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.EnsembleSolver","page":"API Reference","title":"SimulationBasedInference.EnsembleSolver","text":"EnsembleSolver{algType,probType,ensalgType,stateType<:EnsembleState,kwargTypes}\n\nGeneric implementation of an iterative solver for any ensemble-based algorithm. Uses the SciML EnsembleProblem interface to automatically parallelize forward runs over the ensemble.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.GaussianApproximationMethod","page":"API Reference","title":"SimulationBasedInference.GaussianApproximationMethod","text":"GaussianApproximationMethod\n\nBase type for Gaussian approximations of arbitrary prior distributions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.JointPrior","page":"API Reference","title":"SimulationBasedInference.JointPrior","text":"JointPrior{modelPriorType<:AbstractPrior,likPriorTypes} <: AbstractPrior\n\nRepresents the \"joint\" prior p(θₘ,θₗ) where θ = [θₘ θₗ] are the full set of parameters in the joint; distribution p(x,θ). θₘ are the model (simulator) parameters and θₗ are the noise/error model parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.JointPrior-Tuple{AbstractPrior, Vararg{SimulatorLikelihood}}","page":"API Reference","title":"SimulationBasedInference.JointPrior","text":"Constructs a JointPrior from the given prior and likelihoods.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.MCMC","page":"API Reference","title":"SimulationBasedInference.MCMC","text":"MCMC{algType,stratType,kwargType} <: SimulatorInferenceAlgorithm\n\nGeneric container type for Markov Chain Monte Carlo (MCMC) based inference algorithms.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.PBS","page":"API Reference","title":"SimulationBasedInference.PBS","text":"Alias for EnIS.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.PriorDistribution","page":"API Reference","title":"SimulationBasedInference.PriorDistribution","text":"PriorDistribution{distTypes<:NamedTuple}\n\nSimple diagonal prior that wraps a NamedTuple of distributions from the Distributions package.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulationArrayStorage","page":"API Reference","title":"SimulationBasedInference.SimulationArrayStorage","text":"SimulationArrayStorage <: SimulationData\n\nSimple implementation of SimulationData that stores all results in generically typed Vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulationData","page":"API Reference","title":"SimulationBasedInference.SimulationData","text":"SimulationData\n\nBase type representing storage for simulation data, i.e. input/output pairs.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem{probType,obsType,configType,names} <: SciMLBase.AbstractSciMLProblem\n\nRepresents a \"forward\" problem from parameters/initial conditions to output SimulatorObservables.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem-Tuple{Any, AbstractVector, Vararg{SimulatorObservable}}","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem(f, p0::AbstractVector, observables::SimulatorObservable...)\n\nCreates a forward problem from the given function or callable type f with initial parameters p0 and the given observables.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem-Tuple{Any, AbstractVector}","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem(f, p0::AbstractVector)\n\nCreates a forward problem from the given function or callable type f with initial parameters p0 and a default transient observable.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem-Tuple{SciMLBase.AbstractSciMLProblem, Vararg{SimulatorObservable}}","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem(prob::SciMLBase.AbstractSciMLProblem, observables::SimulatorObservable...)\n\nConstructs a generic simulator forward problem from the given AbstractSciMLProblem; note that this could be any problem type, e.g. an optimization problem, nonlinear system, quadrature, etc.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorForwardSolution","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardSolution","text":"SimulatorForwardSolution{TSol}\n\nSolution for a SimulatorForwardProblem that wraps the underlying DESolution.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorForwardSolver","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardSolver","text":"SimulatorForwardSolver{stateType}\n\nBasic forward solver that simply wraps the value returned by init for the underlying problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorInferenceAlgorithm","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceAlgorithm","text":"Base type for all simulator-based inference algorithms.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorInferenceProblem","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceProblem","text":"SimulatorInferenceProblem{modelPriorType<:AbstractPrior,uType,solverType} <: SciMLBase.AbstractSciMLProblem\n\nRepresents a generic simulation-based Bayesian inference problem for finding the posterior distribution over model parameters given some observed data.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorInferenceProblem-Tuple{SimulatorForwardProblem, Any, AbstractPrior, Vararg{SimulatorLikelihood}}","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceProblem","text":"SimulatorInferenceProblem(\n    prob::SimulatorForwardProblem,\n    forward_solver,\n    prior::AbstractPrior,\n    likelihoods::SimulatorLikelihood...;\n    metadata::Dict=Dict(),\n)\n\nConstructs a SimulatorInferenceProblem from the given forward problem, prior, and likelihoods. Additional user-specified metadata may be included in the metadata dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorInferenceSolution","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceSolution","text":"SimulatorInferenceSolution{algType,probType,storageType}\n\nGeneric container for solutions to SimulatorInferenceProblems. The type of result is method dependent and should generally correspond to the final state or product of the inference algorithm (e.g. posterior sampels). The field output should be an instance of SimulationData\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorLikelihood","page":"API Reference","title":"SimulationBasedInference.SimulatorLikelihood","text":"SimulatorLikelihood{distType,obsType,dataType,priorType}\n\nRepresents a simulator-based likelihood function. A SimulatorLikelihood consists of four basic components:\n\n(1) A distribution type, e.g. Normal,\n\n(2) A SimulatorObservable which represents the observation operator,\n\n(3) A set of data, usually a Vector or Matrix, which matches the structure of the observable,\n\n(4) A prior distribution governing one or more additional parameters required to compute the likelihood.\n\nDue to the typically high cost of evaluating the parameter forward map, SimulatorLikelihood effectively decouples the computation of the likelihood from the simulator via the SimulatorObservable, which stores the result of a forward simulation. When the SimulatorLikelihood is evaluated, these outputs are obtained from retrieve(obs) and the only additional parameters needed are those specified by prior.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorODEForwardSolver","page":"API Reference","title":"SimulationBasedInference.SimulatorODEForwardSolver","text":"SimulatorODEForwardSolver{algType,uType,tType,iip,integratorType<:AbstractODEIntegrator{algType,iip,uType,tType}} <: AbstractODEIntegrator{algType,iip,uType,tType}\n\nSpecialized integrator type that wraps a SciML ODE integrator and controls the stepping procedure such that each observable sample point is hit.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorObservable","page":"API Reference","title":"SimulationBasedInference.SimulatorObservable","text":"SimulatorObservable{N,outputType<:SimulatorOutput,funcType,coordsType} <: Observable{outputType}\n\nRepresents a named \"observable\" that stores output from a simulator. obsfunc defines a mapping from the simulator state to the observed quantity. The type and implementation of output determines how the samples are stored. The simplest output type is Transient which simply maintains a pointer to the last observed output.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorObservable-Tuple{Symbol, Function, Tuple}","page":"API Reference","title":"SimulationBasedInference.SimulatorObservable","text":"SimulatorObservable(name::Symbol, f::Function, coords::Tuple)\n\nConstructs a Transient observable with state mapping function f and coordinates coords.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorObservable-Union{Tuple{tType}, Tuple{Symbol, Any, tType, AbstractVector{tType}, Tuple}} where tType","page":"API Reference","title":"SimulationBasedInference.SimulatorObservable","text":"SimulatorObservable(\n    name::Symbol,\n    obsfunc,\n    t0::tType,\n    tsave::AbstractVector{tType},\n    output_shape_or_coords::Tuple;\n    reducer=mean,\n    samplerate=Hour(3),\n) where {tType}\n\nConstructs a TimeSampled observable which iteratively samples and stores outputs on each call to observe!.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonSolve.init","page":"API Reference","title":"CommonSolve.init","text":"init(::SimulatorInferenceProblem, ::EKS, ensemble_alg; kwargs...)\n\nInitializes EKS for the given SimulatorInferenceProblem using the Ensemble Kalman Sampling algorithm. This method automatically constructs an EnsembleKalmanProcess from the given inference problem and named_data pairs. If initial_ens is not provided, the initial ensemble is sampled from the prior.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonSolve.init-Tuple{SimulatorForwardProblem{<:SciMLBase.AbstractODEProblem}, Any}","page":"API Reference","title":"CommonSolve.init","text":"init(forward_prob::SimulatorForwardProblem{<:AbstractODEProblem}, ode_alg; p=forward_prob.prob.p, saveat=[], solve_kwargs...)\n\nInitializes a SimulatorODEForwardSolver for the given forward problem and ODE integrator algorithm. Additional keyword arguments are passed through to the integrator init implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonSolve.solve!-Tuple{SimulatorODEForwardSolver}","page":"API Reference","title":"CommonSolve.solve!","text":"solve!(prob::SimulatorForwardProblem, ode_alg, p; kwargs...)\n\nSolves the forward problem using the given diffeq algorithm and parameters p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LogDensityProblems.logdensity-Tuple{SimulatorInferenceProblem, Any}","page":"API Reference","title":"LogDensityProblems.logdensity","text":"logdensity(inference_prob::SimulatorInferenceProblem, x; kwargs...)\n\nApplies the inverse transformation defined by bijector and calculates the logjoint density. Note that this requires evaluating the likelihood/forward-map, which may involve running the simulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.autoprior-Tuple{Any, Any}","page":"API Reference","title":"SimulationBasedInference.autoprior","text":"autoprior(mean, stddev; lower=-Inf, upper=Inf)\n\nHelper function that automatically constructs a prior distribution with the given mean, standard deviation, and support. Note that lower < mean <= upper must be satisfied. For unbounded variables, Normal is returned. For variabels bounded from below (i.e. either lower or upper bound is finite), a transformed LogNormal distribution is constructed. For double bounded variables, (i.e. both lower and upper are finite) a tranformed Beta distribution is constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.coordinates-Tuple","page":"API Reference","title":"SimulationBasedInference.coordinates","text":"coordinates(dims...)\n\nConverts arguments dims to a tuple of coordinate Dimensions according to the following rules:\n\n- Integers `n` are converted to simple step indices `1:n`\n- Vectors are converted to `Dim`s\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.coordinates-Tuple{SimulationBasedInference.Observable}","page":"API Reference","title":"SimulationBasedInference.coordinates","text":"coordinates(obs::Observable)\n\nRetrieves coordinates for each dimension of the observables as a Tuple with length matching the number of dimensions. Default implementation returns 1:Nᵢ in each dimension where Nᵢ is the size of dimension i.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.ensemble_kalman_analysis-Tuple{AbstractVecOrMat, AbstractVector, AbstractMatrix, Any, Any}","page":"API Reference","title":"SimulationBasedInference.ensemble_kalman_analysis","text":"ensemble_kalman_analysis(\n    prior::AbstractVecOrMat,\n    obs::AbstractVector,\n    pred::AbstractMatrix,\n    alpha,\n    R_cov;\n    ρ_AB=1.0,\n    ρ_BB=1.0,\n    stochastic=true,\n    dosvd=true,\n    svd_thresh=0.90,\n    rng::AbstractRNG=Random.GLOBAL_RNG,\n)\n\nPerforms a single ensemble Kalman analysis step. Adapted from the python implementation by Kristoffer Aalstad:\n\nhttps://github.com/ealonsogzl/MuSA/blob/0c02b8dc25a0f902bf63099de68174f4738705f0/modules/filters.py#L33\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.forward_map-Tuple{AbstractPrior, Any}","page":"API Reference","title":"SimulationBasedInference.forward_map","text":"forward_map(prior::AbstractPrior, x)\n\nApplies the forward map from the sample space of the prior to the parameter space of the forward model (simulator). Note that this mapping need not necessarily be bijective in the case of hierarchical or reparamterized formulations of the model parameter prior. Defaults to returning identity(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.from_moments-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Distribution","page":"API Reference","title":"SimulationBasedInference.from_moments","text":"from_moments(::Type{T}, mean, stddev) where {T<:Distribution}\n\nConstruct a distribution of type T using the method of moments. It is assumed that the given mean lies within the untransformed support of the distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.gaussian_approx-Tuple{EmpiricalGaussian, AbstractPrior}","page":"API Reference","title":"SimulationBasedInference.gaussian_approx","text":"gaussian_gapprox(prior::AbstractPrior; num_prior_samples::Int=10_000, rng::Random.AbstractRNG=Random.default_rng())\n\nBuilds an empirical multivariate Gaussian approximation of the given prior distribution by computing the moments of the transformed samples.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.get_ensemble","page":"API Reference","title":"SimulationBasedInference.get_ensemble","text":"get_ensemble(sol::SimulatorInferenceSolution{<:EnsembleInferenceAlgorithm}, iter::Int=-1)\n\nFetches the state of the ensemble from the given solution object. For iterative algorithms, the optinal argument iter may be provided, which then retrieves the ensemble at the given iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.get_ensemble-Tuple{SimulationBasedInference.EnsembleState}","page":"API Reference","title":"SimulationBasedInference.get_ensemble","text":"get_ensemble(state::EnsembleState)\n\nRetrieves the current ensemble matrix from the given EnsembleState. Must be implemented for each ensemble algorithm state type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.get_observables","page":"API Reference","title":"SimulationBasedInference.get_observables","text":"get_observables(sol::SimulatorInferenceSolution{<:EnsembleInferenceAlgorithm}, iter::Int=-1)\n\nReturns a NamedTuple of concatenated observables at iteration iter.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.get_transformed_ensemble","page":"API Reference","title":"SimulationBasedInference.get_transformed_ensemble","text":"get_transformed_ensemble(sol::SimulatorInferenceSolution{<:EnsembleInferenceAlgorithm}, iter::Int=-1)\n\nFetches the transformed ensemble from the given solution object. For iterative algorithms, the optinal argument iter may be provided, which then retrieves the ensemble at the given iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.importance_weights-Tuple{AbstractVector, AbstractMatrix, Any}","page":"API Reference","title":"SimulationBasedInference.importance_weights","text":"importance_weights(obs::AbstractVector, pred::AbstractMatrix, R::AbstractMatrix)\n\nComputes the importance weights from the given observations, predictions, and noise covariance. When used for data assimilation, this algorithm is also known as the \"particle batch smoother\". This implementation is adapted from the python implementation by Kristoffer Aalstad:\n\nhttps://github.com/ealonsogzl/MuSA/blob/0c02b8dc25a0f902bf63099de68174f4738705f0/modules/filters.py#L169\n\nOriginal docstring:\n\nInputs:     obs: Observation vector (m x 1 array)     pred: Predicted observation ensemble matrix (m x N array)     R: Observation error covariance 'matrix' (m x 1 array, or scalar) Outputs:     w: Posterior weights (N x 1 array)     Neff: Effective sample size Dimensions:     N is the number of ensemble members and m is the number     of observations.\n\nHere we have implemented the particle batch smoother, which is a batch-smoother version of the particle filter (i.e. a particle filter without resampling), described in Margulis et al. (2015, doi: 10.1175/JHM-D-14-0177.1). As such, this routine can also be used for particle filtering with sequential data assimilation. This scheme is obtained by using a particle (mixture of Dirac delta functions) representation of the prior and applying this directly to Bayes theorem. In other words, it is just an application of importance sampling with the prior as the proposal density (importance distribution). It is also the same as the Generalized Likelihood Uncertainty Estimation (GLUE) technique (with a formal Gaussian likelihood)which is widely used in hydrology.\n\nThis particular scheme assumes that the observation errors are additive Gaussian white noise (uncorrelated in time and space). The \"logsumexp\" trick is used to deal with potential numerical issues with floating point operations that occur when dealing with ratios of likelihoods that vary by many orders of magnitude.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.loglikelihood-Tuple{SimulatorLikelihood, Vararg{Any}}","page":"API Reference","title":"SimulationBasedInference.loglikelihood","text":"loglikelihood(lik::SimulatorLikelihood, args...)\n\nEvaluates the log-lielihood of lik on the current observable state by constructing the predictive_distribution and evaluating the logpdf of the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.logprob-Tuple{UnivariateDistribution, Number}","page":"API Reference","title":"SimulationBasedInference.logprob","text":"logprob(d::UnivariateDistribution, x::Number)\n\nAlias for logpdf(d,x) on Distribution types.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.obscov-Tuple{AbstractMatrix}","page":"API Reference","title":"SimulationBasedInference.obscov","text":"obscov(::AbstractMatrix)\nobscov(::AbstractVector)\nobscov(::Number)\n\nBuilds a standard form multivariate normal covariance matrix from the given matrix, vector (diagonal), or scalar (isotropic).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.obscov-Tuple{Vararg{SimulatorLikelihood}}","page":"API Reference","title":"SimulationBasedInference.obscov","text":"obscov(likelihoods::SimulatorLikelihood...)\n\nImplementations should build a combined covariance matrix from the given likelihood types. The default implementation simply throws an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.observe!-Tuple{SimulationBasedInference.Observable, Any}","page":"API Reference","title":"SimulationBasedInference.observe!","text":"observe!(::Observable, state)\n\nComputes and stores the relevant state variables from the given simulator state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.prior","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(args...; kwargs...)\n\nGeneric constructor for prior distribution types that can be implemented by subtypes of AbstractPrior.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.prior-Tuple{SimulatorInferenceProblem}","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(prob::SimulatorInferenceProblem)\n\nRetrieves the prior from the given SimulatorInferenceProblem.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.prior-Tuple{Symbol, Distribution}","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(name::Symbol, dist::Distribution)\n\nAlias for PriorDistribution((name = dist)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.prior-Tuple{}","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(; dists...)\n\nAlias for PriorDistribution((; dists...)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.retrieve-Union{Tuple{SimulationBasedInference.Observable}, Tuple{T}, Tuple{SimulationBasedInference.Observable, Type{T}}} where T","page":"API Reference","title":"SimulationBasedInference.retrieve","text":"retrieve(::Observable, ::Type{T}=Any) where {T}\n\nRetreive the obsevable at all coordinates, assuming all sample times have been stored appropriately.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.store!-Tuple{SimulationData, AbstractVector, Any}","page":"API Reference","title":"SimulationBasedInference.store!","text":"store!(::SimulationData, x::AbstractVector, y)\n\nStores the input/output pair x/y in the given forward map storage container.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.unconstrained_forward_map-Tuple{AbstractPrior, Any}","page":"API Reference","title":"SimulationBasedInference.unconstrained_forward_map","text":"unconstrained_forward_map(prior::AbstractPrior, ζ)\n\nApplies the forward map from unconstrained to forward model parameter (g ∘ f): Ζ ↦ Θ ↦ Φ where f⁻¹ is the inverse bijector of prior (i.e. mapping from unconstrained Ζ to constrained Θ space) and g is defined by forward_map which maps from Θ to the parameter space of the forward model, Φ.\n\n\n\n\n\n","category":"method"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"EditURL = \"../../../examples/linearode/linearode.jl\"","category":"page"},{"location":"examples/linearode/#linearode","page":"Ensemble inversion of a linear ODE","title":"Getting started: Linear ODE inversion","text":"","category":"section"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"In this example, we will use SimulationBasedInference in combination with the OrdinaryDiffEq package to recover the true parameter of a simple linear ordinary differential equation:","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"fracpartial upartial t = -alpha u","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Of course, this ODE has an analytical solution: u(t) = u_0 e^-alpha t which we could (more efficiently) use to define the inverse problem. However, in order to demonstrate the usage of SimulationBasedInference on dynamical systems more broadly, we will solve the problem using numerical methods.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"First, we load the necessary packages","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"using SimulationBasedInference\nusing OrdinaryDiffEq\nusing Plots, StatsPlots\nimport Random\n","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"and then initialize a random number generator for reproducibility.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"const rng = Random.MersenneTwister(1234);","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Now, we will define our simple dynamical system using the general SciML problem interface:","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"ode_func(u,p,t) = -p[1]*u;\nα_true = 0.2\node_p = [α_true];\ntspan = (0.0,10.0);\nodeprob = ODEProblem(ode_func, [1.0], tspan, ode_p)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: false\ntimespan: (0.0, 10.0)\nu0: 1-element Vector{Float64}:\n 1.0","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"To solve an inverse (or inference) problem with SimulationBasedInference, we must first define a forward problem. The forward problem consists of two components:","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"A SciML problem type or forward map function f Theta mapsto mathcalU.\nOne or more \"observables\" which define the observation operator that transforms the model state to","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"to something comparable to data.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"In this case, we can simply define a function that extracts the current state from the ODE integrator. The SimulatorObservable(name, func, t0, tsave, coords) additionally takes an initial time point, a vector of observed time points, and a tuple specifying the shape or coordiantes of the observable at each time point. Here, (1,) indicates that the state is a one-dimensional vector.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"tsave = tspan[1]+0.1:0.2:tspan[end];\nn_obs = length(tsave);\nobservable = SimulatorObservable(:y, integrator -> integrator.u, tspan[1], tsave, (1,), samplerate=0.01);\nforward_prob = SimulatorForwardProblem(odeprob, observable)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"SimulatorForwardProblem (ODEProblem) with 1 observables (:y,)\n","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"In order to set up our synthetic example, we need to some data to infer from. Here we generate the data by running the forward model and adding Gaussian noise.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"ode_solver = Tsit5()\nforward_sol = solve(forward_prob, ode_solver, saveat=0.01);\ntrue_obs = get_observable(forward_sol, :y)\nnoise_scale = 0.05\nnoisy_obs = true_obs .+ noise_scale*randn(rng, n_obs);","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"plot the results","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"plot(forward_sol.sol, label=\"True solution\", linewidth=3, color=:black)\nplt = scatter!(tsave, noisy_obs, label=\"Noisy observations\", alpha=0.5)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"(Image: )","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Here we set our priors. We use a weakly informative Beta(2,2) prior which puts less mass at the tails. We could also use a flat prior Beta(1,1) if we wanted to be more agnostic to further minimize the influence of the prior.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"model_prior = prior(α=Beta(2,2));\nnoise_scale_prior = prior(σ=Exponential(noise_scale));\np1 = Plots.plot(model_prior.dist.α)\np2 = Plots.plot(noise_scale_prior.dist.σ)\nplt = Plots.plot(p1, p2)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"(Image: )","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Now we assign a simple Gaussian likelihood for the obsevation/noise model.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"lik = SimulatorLikelihood(IsoNormal, observable, noisy_obs, noise_scale_prior);","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"We now have all of the ingredients needed to set up and solve the inference problem. We will start with a simple ensemble importance sampling inference algorithm.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"inference_prob = SimulatorInferenceProblem(forward_prob, ode_solver, model_prior, lik);\nenis_sol = solve(inference_prob, EnIS(), ensemble_size=128, rng=rng);","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"We can extract the prior ensemble from the solution.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"prior_ens = get_transformed_ensemble(enis_sol)\nprior_ens_mean = mean(prior_ens, dims=2)[:,1]\nprior_ens_std = std(prior_ens, dims=2)[:,1]\nprior_ens_obs = get_observables(enis_sol).y;\nprior_ens_obs_mean = mean(prior_ens_obs, dims=2)[:,1]\nprior_ens_obs_std = std(prior_ens_obs, dims=2)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"In contrast to other inference algorithms, importance sampling produces weights rather than direct samples from the posterior. We can use the get_weights method to extract these from the solution.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"importance_weights = get_weights(enis_sol);","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"We can then use these importance weights to compute weighted statistics using standard methods from the Statistics and StatsBase modules. Note that these modules are exported by SimulationBasedInference for convenience.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"posterior_obs_mean_enis = mean(prior_ens_obs, weights(importance_weights), 2)[:,1]\nposterior_obs_std_enis = std(prior_ens_obs, weights(importance_weights), 2)[:,1]\nposterior_mean_enis = mean(prior_ens, weights(importance_weights))","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"0.21222358138901481","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Now we plot the prior vs. the posterior predictions.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"plot(tsave, true_obs, label=\"True solution\", c=:black, linewidth=2, title=\"Importance weighted posterior predictions\")\nplot!(tsave, prior_ens_obs_mean, label=\"Prior\", c=:gray, linestyle=:dash, ribbon=2*prior_ens_obs_std, alpha=0.5, linewidth=2)\nplot!(tsave, posterior_obs_mean_enis, label=\"Posterior\", c=:blue, linestyle=:dash, ribbon=2*posterior_obs_std_enis, alpha=0.7, linewidth=2)\nplt = scatter!(tsave, noisy_obs, label=\"Noisy observations\", c=:orange)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"(Image: )","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"One of the key benefits of the standard problem interface is that we can very easily switch to a different algorithm by changing a single line of code. Here, we solve the same inference problem instead with the ensemble smoother w/ \"multiple data assimilation\" (ES-MDA).","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"esmda_sol = solve(inference_prob, ESMDA(), ensemble_size=128, rng=rng);","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Now we extract the posterior ensemble and compute the relevant statistics.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"posterior_esmda = get_transformed_ensemble(esmda_sol)\nposterior_mean_esmda = mean(posterior_esmda, dims=2)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"1×1 Matrix{Float64}:\n 0.20597582729899466","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Plotting the predictions shows that we get a much tighter estimate of the posterior mean.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"posterior_obs_esmda = get_observables(esmda_sol).y\nposterior_obs_mean_esmda = mean(posterior_obs_esmda, dims=2)[:,1]\nposterior_obs_std_esmda = std(posterior_obs_esmda, dims=2)[:,1]\nplot(tsave, true_obs, label=\"True solution\", c=:black, linewidth=2, title=\"ES-MDA\")\nplot!(tsave, prior_ens_obs_mean, label=\"Prior\", c=:gray, linestyle=:dash, ribbon=2*prior_ens_obs_std, alpha=0.5, linewidth=2)\nplot!(tsave, posterior_obs_mean_esmda, label=\"Posterior\", c=:blue, linestyle=:dash, ribbon=2*posterior_obs_std_esmda, alpha=0.7, linewidth=2)\nplt = scatter!(tsave, noisy_obs, label=\"Noisy observations\", c=:black)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"(Image: )","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"We can again solve the same problem with the Ensemble Kalman Sampler of Garbuno-Inigo et al. (2020) which yields very similar results (in this case).","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"eks_sol = solve(inference_prob, EKS(), ensemble_size=128, rng=rng, verbose=false)\nposterior_eks = get_transformed_ensemble(eks_sol)\nposterior_mean_eks = mean(posterior_eks, dims=2)\nposterior_obs_eks = get_observables(eks_sol).y\nposterior_obs_mean_eks = mean(posterior_obs_eks, dims=2)[:,1]\nposterior_obs_std_eks = std(posterior_obs_eks, dims=2)[:,1]\nplot(tsave, true_obs, label=\"True solution\", c=:black, linewidth=2, title=\"EKS\")\nplot!(tsave, prior_ens_obs_mean, label=\"Prior\", c=:gray, linestyle=:dash, ribbon=2*prior_ens_obs_std, alpha=0.5, linewidth=2)\nplot!(tsave, posterior_obs_mean_eks, label=\"Posterior\", c=:blue, linestyle=:dash, ribbon=2*posterior_obs_std_eks, alpha=0.7, linewidth=2)\nplt = scatter!(tsave, noisy_obs, label=\"Noisy observations\", c=:black)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"(Image: )","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"Finally, we can plot the posterior predictions of all of the algorithms and compare.","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"plot(tsave, true_obs, label=\"True solution\", c=:black, linewidth=2, title=\"EKS\")\nplot!(tsave, prior_ens_obs_mean, label=\"Prior\", c=:gray, linestyle=:dash, ribbon=2*prior_ens_obs_std, alpha=0.5, linewidth=2)\nplot!(tsave, posterior_obs_mean_enis, label=\"Posterior (EnIS)\", linestyle=:dash, ribbon=2*posterior_obs_std_enis, alpha=0.5, linewidth=3)\nplot!(tsave, posterior_obs_mean_esmda, label=\"Posterior (ES-MDA)\", linestyle=:dash, ribbon=2*posterior_obs_std_esmda, alpha=0.5, linewidth=3)\nplot!(tsave, posterior_obs_mean_eks, dims=2, label=\"Posterior (EKS)\", linestyle=:dash, ribbon=2*posterior_obs_std_eks, alpha=0.5, linewidth=3)\nplt = scatter!(tsave, noisy_obs, label=\"Noisy observations\", c=:black)","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"(Image: )","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"","category":"page"},{"location":"examples/linearode/","page":"Ensemble inversion of a linear ODE","title":"Ensemble inversion of a linear ODE","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#SimulationBasedInference.jl","page":"Home","title":"SimulationBasedInference.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimulationBasedInference.jl aims to bring together a variety of different methods for simulation-based inference, i.e. statistical inference with simulator-like models, in the Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please note that this package is still very much under construction and things may break or change without prior notice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to use this package in your work, please let us know by creating an issue on GitHub or sending an email to brian.groenke@awi.de","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimulationBasedInference can be installed via the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add SimulationBasedInference","category":"page"},{"location":"","page":"Home","title":"Home","text":"or equivalently in code/REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"SimulationBasedInference\")","category":"page"}]
}
