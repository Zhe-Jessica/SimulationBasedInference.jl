var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"Index of full API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [SimulationBasedInference]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/#SimulationBasedInference.EKS","page":"API Reference","title":"SimulationBasedInference.EKS","text":"EKS <: EnsembleInferenceAlgorithm\n\nRepresents a proxy for the Ensemble Kalman Sampler implementation provided by EnsembleKalmanProcesses.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.EnIS","page":"API Reference","title":"SimulationBasedInference.EnIS","text":"EnIS\n\nBasic ensemble importance sampling (EnIS) inference algorithm. Also sometimes referred to as a \"particle batch smoother\" (PBS) or \"generalized likelihood uncertainty estimation\" (GLUE) depending on the context.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.EnsembleSolver","page":"API Reference","title":"SimulationBasedInference.EnsembleSolver","text":"EnsembleSolver{algType,probType,ensalgType,stateType<:EnsembleState,kwargTypes}\n\nGeneric implementation of an iterative solver for any ensemble-based algorithm. Uses the SciML EnsembleProblem interface to automatically parallelize forward runs over the ensemble.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.JointPrior","page":"API Reference","title":"SimulationBasedInference.JointPrior","text":"JointPrior{modelPriorType<:AbstractPrior,likPriorTypes} <: AbstractPrior\n\nRepresents the \"joint\" prior p(θₘ,θₗ) where θ = [θₘ θₗ] are the full set of parameters in the joint; distribution p(x,θ). θₘ are the model (simulator) parameters and θₗ are the noise/error model parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.JointPrior-Tuple{AbstractPrior, Vararg{SimulatorLikelihood}}","page":"API Reference","title":"SimulationBasedInference.JointPrior","text":"Constructs a JointPrior from the given prior and likelihoods.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.MCMC","page":"API Reference","title":"SimulationBasedInference.MCMC","text":"MCMC{algType,stratType,kwargType} <: SimulatorInferenceAlgorithm\n\nGeneric container type for Markov Chain Monte Carlo (MCMC) based inference algorithms.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.PBS","page":"API Reference","title":"SimulationBasedInference.PBS","text":"Alias for EnIS.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.PriorDistribution","page":"API Reference","title":"SimulationBasedInference.PriorDistribution","text":"PriorDistribution{distTypes<:NamedTuple}\n\nSimple diagonal prior that wraps a NamedTuple of distributions from the Distributions package.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulationArrayStorage","page":"API Reference","title":"SimulationBasedInference.SimulationArrayStorage","text":"SimulationArrayStorage <: SimulationData\n\nSimple implementation of SimulationData that stores all results in generically typed Vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulationData","page":"API Reference","title":"SimulationBasedInference.SimulationData","text":"SimulationData\n\nBase type representing storage for simulation data, i.e. input/output pairs.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem{probType,obsType,configType,names} <: SciMLBase.AbstractSciMLProblem\n\nRepresents a \"forward\" problem from parameters/initial conditions to output SimulatorObservables.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem-Tuple{Any, AbstractVector, Vararg{SimulatorObservable}}","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem(f, p0::AbstractVector, observables::SimulatorObservable...)\n\nCreates a forward problem from the given function or callable type f with initial parameters p0 and the given observables.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem-Tuple{Any, AbstractVector}","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem(f, p0::AbstractVector)\n\nCreates a forward problem from the given function or callable type f with initial parameters p0 and a default transient observable.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorForwardProblem-Tuple{SciMLBase.AbstractSciMLProblem, Vararg{SimulatorObservable}}","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardProblem","text":"SimulatorForwardProblem(prob::SciMLBase.AbstractSciMLProblem, observables::SimulatorObservable...)\n\nConstructs a generic simulator forward problem from the given AbstractSciMLProblem; note that this could be any problem type, e.g. an optimization problem, nonlinear system, quadrature, etc.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorForwardSolution","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardSolution","text":"SimulatorForwardSolution{TSol}\n\nSolution for a SimulatorForwardProblem that wraps the underlying DESolution.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorForwardSolver","page":"API Reference","title":"SimulationBasedInference.SimulatorForwardSolver","text":"SimulatorForwardSolver{stateType}\n\nBasic forward solver that simply wraps the value returned by init for the underlying problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorInferenceAlgorithm","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceAlgorithm","text":"Base type for all simulator-based inference algorithms.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorInferenceProblem","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceProblem","text":"SimulatorInferenceProblem{modelPriorType<:AbstractPrior,uType,solverType} <: SciMLBase.AbstractSciMLProblem\n\nRepresents a generic simulation-based Bayesian inference problem for finding the posterior distribution over model parameters given some observed data.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorInferenceProblem-Tuple{SimulatorForwardProblem, Any, AbstractPrior, Vararg{SimulatorLikelihood}}","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceProblem","text":"SimulatorInferenceProblem(\n    prob::SimulatorForwardProblem,\n    forward_solver,\n    prior::AbstractPrior,\n    likelihoods::SimulatorLikelihood...;\n    metadata::Dict=Dict(),\n)\n\nConstructs a SimulatorInferenceProblem from the given forward problem, prior, and likelihoods. Additional user-specified metadata may be included in the metadata dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorInferenceSolution","page":"API Reference","title":"SimulationBasedInference.SimulatorInferenceSolution","text":"SimulatorInferenceSolution{algType,probType,storageType}\n\nGeneric container for solutions to SimulatorInferenceProblems. The type of result is method dependent and should generally correspond to the final state or product of the inference algorithm (e.g. posterior sampels). The field output should be an instance of SimulationData\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorLikelihood","page":"API Reference","title":"SimulationBasedInference.SimulatorLikelihood","text":"SimulatorLikelihood{distType,obsType,dataType,priorType}\n\nRepresents a simulator-based likelihood function. A SimulatorLikelihood consists of four basic components:\n\n(1) A distribution type, e.g. Normal,\n\n(2) A SimulatorObservable which represents the observation operator,\n\n(3) A set of data, usually a Vector or Matrix, which matches the structure of the observable,\n\n(4) A prior distribution governing one or more additional parameters required to compute the likelihood.\n\nDue to the typically high cost of evaluating the parameter forward map, SimulatorLikelihood effectively decouples the computation of the likelihood from the simulator via the SimulatorObservable, which stores the result of a forward simulation. When the SimulatorLikelihood is evaluated, these outputs are obtained from retrieve(obs) and the only additional parameters needed are those specified by prior.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorODEForwardSolver","page":"API Reference","title":"SimulationBasedInference.SimulatorODEForwardSolver","text":"SimulatorODEForwardSolver{algType,uType,tType,iip,integratorType<:AbstractODEIntegrator{algType,iip,uType,tType}} <: AbstractODEIntegrator{algType,iip,uType,tType}\n\nSpecialized integrator type that wraps a SciML ODE integrator and controls the stepping procedure such that each observable sample point is hit.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorObservable","page":"API Reference","title":"SimulationBasedInference.SimulatorObservable","text":"SimulatorObservable{N,outputType<:SimulatorOutput,funcType,coordsType} <: Observable{outputType}\n\nRepresents a named \"observable\" that stores output from a simulator. obsfunc defines a mapping from the simulator state to the observed quantity. The type and implementation of output determines how the samples are stored. The simplest output type is Transient which simply maintains a pointer to the last observed output.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationBasedInference.SimulatorObservable-Tuple{Symbol, Function, Tuple}","page":"API Reference","title":"SimulationBasedInference.SimulatorObservable","text":"SimulatorObservable(name::Symbol, f::Function, coords::Tuple)\n\nConstructs a Transient observable with state mapping function f and coordinates coords.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.SimulatorObservable-Union{Tuple{tType}, Tuple{Symbol, Any, tType, AbstractVector{tType}, Tuple}} where tType","page":"API Reference","title":"SimulationBasedInference.SimulatorObservable","text":"SimulatorObservable(\n    name::Symbol,\n    obsfunc,\n    t0::tType,\n    tsave::AbstractVector{tType},\n    output_shape_or_coords::Tuple;\n    reducer=mean,\n    samplerate=Hour(3),\n) where {tType}\n\nConstructs a TimeSampled observable which iteratively samples and stores outputs on each call to observe!.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonSolve.init","page":"API Reference","title":"CommonSolve.init","text":"init(::SimulatorInferenceProblem, ::EKS, ensemble_alg; kwargs...)\n\nInitializes EKS for the given SimulatorInferenceProblem using the Ensemble Kalman Sampling algorithm. This method automatically constructs an EnsembleKalmanProcess from the given inference problem and named_data pairs. If initial_ens is not provided, the initial ensemble is sampled from the prior.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonSolve.init-Tuple{SimulatorForwardProblem{<:SciMLBase.AbstractODEProblem}, Any}","page":"API Reference","title":"CommonSolve.init","text":"init(forward_prob::SimulatorForwardProblem{<:AbstractODEProblem}, ode_alg; p=forward_prob.prob.p, saveat=[], solve_kwargs...)\n\nInitializes a SimulatorODEForwardSolver for the given forward problem and ODE integrator algorithm. Additional keyword arguments are passed through to the integrator init implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonSolve.solve!-Tuple{SimulatorODEForwardSolver}","page":"API Reference","title":"CommonSolve.solve!","text":"solve!(prob::SimulatorForwardProblem, ode_alg, p; kwargs...)\n\nSolves the forward problem using the given diffeq algorithm and parameters p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LogDensityProblems.logdensity-Tuple{SimulatorInferenceProblem, Any}","page":"API Reference","title":"LogDensityProblems.logdensity","text":"logdensity(inference_prob::SimulatorInferenceProblem, x; kwargs...)\n\nApplies the inverse transformation defined by bijector and calculates the logjoint density. Note that this requires evaluating the likelihood/forward-map, which may involve running the simulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.autoprior-Tuple{Any, Any}","page":"API Reference","title":"SimulationBasedInference.autoprior","text":"autoprior(mean, stddev; lower=-Inf, upper=Inf)\n\nHelper function that automatically constructs a prior distribution with the given mean, standard deviation, and support. Note that lower < mean <= upper must be satisfied. For unbounded variables, Normal is returned. For variabels bounded from below (i.e. either lower or upper bound is finite), a transformed LogNormal distribution is constructed. For double bounded variables, (i.e. both lower and upper are finite) a tranformed Beta distribution is constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.coordinates-Tuple","page":"API Reference","title":"SimulationBasedInference.coordinates","text":"coordinates(dims...)\n\nConverts arguments dims to a tuple of coordinate Dimensions according to the following rules:\n\n- Integers `n` are converted to simple step indices `1:n`\n- Vectors are converted to `Dim`s\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.coordinates-Tuple{SimulationBasedInference.Observable}","page":"API Reference","title":"SimulationBasedInference.coordinates","text":"coordinates(obs::Observable)\n\nRetrieves coordinates for each dimension of the observables as a Tuple with length matching the number of dimensions. Default implementation returns 1:Nᵢ in each dimension where Nᵢ is the size of dimension i.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.ensemble_kalman_analysis-Tuple{AbstractVecOrMat, AbstractVector, AbstractMatrix, Any, Any}","page":"API Reference","title":"SimulationBasedInference.ensemble_kalman_analysis","text":"ensemble_kalman_analysis(\n    prior::AbstractVecOrMat,\n    obs::AbstractVector,\n    pred::AbstractMatrix,\n    alpha,\n    R_cov;\n    ρ_AB=1.0,\n    ρ_BB=1.0,\n    stochastic=true,\n    dosvd=true,\n    svd_thresh=0.90,\n    rng::AbstractRNG=Random.GLOBAL_RNG,\n)\n\nPerforms a single ensemble Kalman analysis step. Adapted from the python implementation by Kristoffer Aalstad:\n\nhttps://github.com/ealonsogzl/MuSA/blob/0c02b8dc25a0f902bf63099de68174f4738705f0/modules/filters.py#L33\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.forward_map-Tuple{AbstractPrior, Any}","page":"API Reference","title":"SimulationBasedInference.forward_map","text":"forward_map(prior::AbstractPrior, x)\n\nApplies the forward map from the sample space of the prior to the parameter space of the forward model (simulator). Note that this mapping need not necessarily be bijective in the case of hierarchical or reparamterized formulations of the model parameter prior. Defaults to returning identity(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.from_moments-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Distribution","page":"API Reference","title":"SimulationBasedInference.from_moments","text":"from_moments(::Type{T}, mean, stddev) where {T<:Distribution}\n\nConstruct a distribution of type T using the method of moments. It is assumed that the given mean lies within the untransformed support of the distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.gaussian_approx-Tuple{EmpiricalGaussian, AbstractPrior}","page":"API Reference","title":"SimulationBasedInference.gaussian_approx","text":"gaussian_gapprox(prior::AbstractPrior; num_prior_samples::Int=10_000, rng::Random.AbstractRNG=Random.default_rng())\n\nBuilds an empirical multivariate Gaussian approximation of the given prior distribution by computing the moments of the transformed samples.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.get_ensemble","page":"API Reference","title":"SimulationBasedInference.get_ensemble","text":"get_ensemble(sol::SimulatorInferenceSolution{<:EnsembleInferenceAlgorithm}, iter::Int=-1)\n\nFetches the state of the ensemble from the given solution object. For iterative algorithms, the optinal argument iter may be provided, which then retrieves the ensemble at the given iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.get_ensemble-Tuple{SimulationBasedInference.EnsembleState}","page":"API Reference","title":"SimulationBasedInference.get_ensemble","text":"get_ensemble(state::EnsembleState)\n\nRetrieves the current ensemble matrix from the given EnsembleState. Must be implemented for each ensemble algorithm state type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.get_observables","page":"API Reference","title":"SimulationBasedInference.get_observables","text":"get_observables(sol::SimulatorInferenceSolution{<:EnsembleInferenceAlgorithm}, iter::Int=-1)\n\nReturns a NamedTuple of concatenated observables at iteration iter.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.get_transformed_ensemble","page":"API Reference","title":"SimulationBasedInference.get_transformed_ensemble","text":"get_transformed_ensemble(sol::SimulatorInferenceSolution{<:EnsembleInferenceAlgorithm}, iter::Int=-1)\n\nFetches the transformed ensemble from the given solution object. For iterative algorithms, the optinal argument iter may be provided, which then retrieves the ensemble at the given iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.importance_weights-Tuple{AbstractVector, AbstractMatrix, Any}","page":"API Reference","title":"SimulationBasedInference.importance_weights","text":"importance_weights(obs::AbstractVector, pred::AbstractMatrix, R::AbstractMatrix)\n\nComputes the importance weights from the given observations, predictions, and noise covariance. When used for data assimilation, this algorithm is also known as the \"particle batch smoother\". This implementation is adapted from the python implementation by Kristoffer Aalstad:\n\nhttps://github.com/ealonsogzl/MuSA/blob/0c02b8dc25a0f902bf63099de68174f4738705f0/modules/filters.py#L169\n\nOriginal docstring:\n\nInputs:     obs: Observation vector (m x 1 array)     pred: Predicted observation ensemble matrix (m x N array)     R: Observation error covariance 'matrix' (m x 1 array, or scalar) Outputs:     w: Posterior weights (N x 1 array)     Neff: Effective sample size Dimensions:     N is the number of ensemble members and m is the number     of observations.\n\nHere we have implemented the particle batch smoother, which is a batch-smoother version of the particle filter (i.e. a particle filter without resampling), described in Margulis et al. (2015, doi: 10.1175/JHM-D-14-0177.1). As such, this routine can also be used for particle filtering with sequential data assimilation. This scheme is obtained by using a particle (mixture of Dirac delta functions) representation of the prior and applying this directly to Bayes theorem. In other words, it is just an application of importance sampling with the prior as the proposal density (importance distribution). It is also the same as the Generalized Likelihood Uncertainty Estimation (GLUE) technique (with a formal Gaussian likelihood)which is widely used in hydrology.\n\nThis particular scheme assumes that the observation errors are additive Gaussian white noise (uncorrelated in time and space). The \"logsumexp\" trick is used to deal with potential numerical issues with floating point operations that occur when dealing with ratios of likelihoods that vary by many orders of magnitude.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.loglikelihood-Tuple{SimulatorLikelihood, Vararg{Any}}","page":"API Reference","title":"SimulationBasedInference.loglikelihood","text":"loglikelihood(lik::SimulatorLikelihood, args...)\n\nEvaluates the log-lielihood of lik on the current observable state by constructing the predictive_distribution and evaluating the logpdf of the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.logprob-Tuple{UnivariateDistribution, Number}","page":"API Reference","title":"SimulationBasedInference.logprob","text":"logprob(d::UnivariateDistribution, x::Number)\n\nAlias for logpdf(d,x) on Distribution types.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.obscov-Tuple{AbstractMatrix}","page":"API Reference","title":"SimulationBasedInference.obscov","text":"obscov(::AbstractMatrix)\nobscov(::AbstractVector)\nobscov(::Number)\n\nBuilds a standard form multivariate normal covariance matrix from the given matrix, vector (diagonal), or scalar (isotropic).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.obscov-Tuple{Vararg{SimulatorLikelihood}}","page":"API Reference","title":"SimulationBasedInference.obscov","text":"obscov(likelihoods::SimulatorLikelihood...)\n\nImplementations should build a combined covariance matrix from the given likelihood types. The default implementation simply throws an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.observe!-Tuple{SimulationBasedInference.Observable, Any}","page":"API Reference","title":"SimulationBasedInference.observe!","text":"observe!(::Observable, state)\n\nComputes and stores the relevant state variables from the given simulator state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.prior","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(args...; kwargs...)\n\nGeneric constructor for prior distribution types that can be implemented by subtypes of AbstractPrior.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationBasedInference.prior-Tuple{SimulatorInferenceProblem}","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(prob::SimulatorInferenceProblem)\n\nRetrieves the prior from the given SimulatorInferenceProblem.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.prior-Tuple{Symbol, Distribution}","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(name::Symbol, dist::Distribution)\n\nAlias for PriorDistribution((name = dist)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.prior-Tuple{}","page":"API Reference","title":"SimulationBasedInference.prior","text":"prior(; dists...)\n\nAlias for PriorDistribution((; dists...)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.retrieve-Union{Tuple{SimulationBasedInference.Observable}, Tuple{T}, Tuple{SimulationBasedInference.Observable, Type{T}}} where T","page":"API Reference","title":"SimulationBasedInference.retrieve","text":"retrieve(::Observable, ::Type{T}=Any) where {T}\n\nRetreive the obsevable at all coordinates, assuming all sample times have been stored appropriately.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.store!-Tuple{SimulationData, AbstractVector, Any}","page":"API Reference","title":"SimulationBasedInference.store!","text":"store!(::SimulationData, x::AbstractVector, y)\n\nStores the input/output pair x/y in the given forward map storage container.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimulationBasedInference.unconstrained_forward_map-Tuple{AbstractPrior, Any}","page":"API Reference","title":"SimulationBasedInference.unconstrained_forward_map","text":"unconstrained_forward_map(prior::AbstractPrior, ζ)\n\nApplies the forward map from unconstrained to forward model parameter (g ∘ f): Ζ ↦ Θ ↦ Φ where f⁻¹ is the inverse bijector of prior (i.e. mapping from unconstrained Ζ to constrained Θ space) and g is defined by forward_map which maps from Θ to the parameter space of the forward model, Φ.\n\n\n\n\n\n","category":"method"},{"location":"#SimulationBasedInference.jl","page":"Home","title":"SimulationBasedInference.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimulationBasedInference.jl aims to bring together a variety of different methods for simulation-based inference, i.e. statistical inference with simulator-like models, in the Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please note that this package is still very much under construction and things may break or change without prior notice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to use this package in your work, please let us know by creating an issue on GitHub or sending an email to brian.groenke@awi.de","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulator-type models are ubiquitous in science and engineering.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most simulator-type models require some kind of input, e.g boundary conditions (forcings), physical properties or constants, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Often, these parameters are not fully known a priori... but usually we know something!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bayesian inference provides a natural framework for constraining this uncertainty using observed data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"p(\\boldsymbol{\\theta} | \\mathbf{y}) = \\frac{p(\\mathbf{y}|\\boldsymbol{\\theta})p(\\boldsymbol{\\theta})}{p(\\mathbf{y})} $","category":"page"},{"location":"","page":"Home","title":"Home","text":"The posterior distribution p(boldsymbolboldsymboltheta  mathbfy) represents our best estimate (with uncertainty) of the unknown parameters boldsymboltheta after observing mathbfy.","category":"page"},{"location":"#Simulation-based-inference","page":"Home","title":"Simulation-based inference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulation-based inference (SBI) [1] refers to the problem of performing statistical inference (Bayesian or otherwise) of unknown parameters boldsymboltheta where the forward model mathcalM:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"y = \\mathcal{M}(\\boldsymbol{\\theta}) + \\epsilon $","category":"page"},{"location":"","page":"Home","title":"Home","text":"is a dynamical model or physics-based simulator mapping from parameters to noisy (epsilon) observations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two fundamental challenges with this problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model mathcalM is almost always non-linear and, in the case of dynamical models, intractable (i.e. we cannot write down the analytical solution a priori).\nEvaluating the forward map mathcalM(boldsymboltheta) is usually non-trivial, i.e. computationally expensive or at least inconvenient.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, classical statistical methods that rely on either analytical or numerical methods to derive the posterior distribution are generally difficult (or impossible) to apply.","category":"page"},{"location":"#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although the term \"simulation-based inference\" is relatively new, the basic problem of statistical inference and uncertainty quantification with dynamical \"simulator\" models is not. In the field of geoscientific modeling in general and weather forecasting in particular, the problem is often referred to as data assimilation [2].","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following is a list of methods which are planned to be included in this package:","category":"page"},{"location":"#Ensemble/particle-algorithms","page":"Home","title":"Ensemble/particle algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Importance sampling, a.k.a particle batch smoothing 3 and generalized likelihood uncertainty estimation 4\n[ ] Particle Filtering/Sequential Monte Carlo 5,6\n[x] Ensemble Kalman sampling and inversion (EKS/EKI) via EnsembleKalmanProcesses.jl [7]\n[x] Ensemble smoother with multiple data assimilation 8\n[ ] Adaptive multiple importance sampling 9 \n[ ] Particle flow filters 10","category":"page"},{"location":"#Density-estimation","page":"Home","title":"Density estimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Sequential neural likelihood/posterior estimation (SNLE/SNPE) via sbi","category":"page"},{"location":"#Hybrid-ensemble-emulator","page":"Home","title":"Hybrid ensemble + emulator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Calibrate, emulate, sample w/ Gaussian Processes 11","category":"page"},{"location":"#Markov-Chain-Monte-Carlo","page":"Home","title":"Markov Chain Monte Carlo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ ] Affine Invariant MCMC 12 via AffineInvariantMCMC.jl","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Cranmer, Kyle, Johann Brehmer, and Gilles Louppe. \"The frontier of simulation-based inference.\" Proceedings of the National Academy of Sciences 117.48 (2020): 30055-30062.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Evensen, Geir, et al. \"Data Assimilation Fundamentals.\", Springer (2022): https://doi.org/10.1007/978-3-030-96709-3","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Margulis, Steven, et al. \"A Particle Batch Smoother Approach to Snow Water Equivalent Estimation.\" J. Hydrometeor. (2015): https://doi.org/10.1175/JHM-D-14-0177.1","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] Beven, Keith, and Andrew Binley. \"GLUE: 20 years on\", Hydrol. Process. (2014): https://doi.org/10.1002/hyp.10082","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] Peter Jan van Leeuwen. \"Particle Filtering in Geophysical Systems\". Mon. Wea. Rev. (2009): https://doi.org/10.1175/2009MWR2835.1","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6] Chopin, Nicolas, and Omiros Papaspiliopoulos. \"An Introduction to Sequential Monte Carlo.\" Springer (2020): https://doi.org/10.1007/978-3-030-47845-2","category":"page"},{"location":"","page":"Home","title":"Home","text":"[7] Dunbar, Oliver R. A. et al. \"EnsembleKalmanProcesses.jl: Derivative-free ensemble-based model calibration.\" Journal of Open Source Software (2022): https://doi.org/10.21105/joss.04869","category":"page"},{"location":"","page":"Home","title":"Home","text":"[8] Emerick, Alexandre A., and Albert C. Reynolds. \"Ensemble smoother with multiple data assimilation.\" Computers & Geosciences (2013): https://doi.org/10.1016/j.cageo.2012.03.011","category":"page"},{"location":"","page":"Home","title":"Home","text":"[9] Cornuet, Jean‐Marie, et al. \"Adaptive multiple importance sampling.\" Scandinavian Journal of Statistics 39.4 (2012): 798-812.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[10] Hu, Chih‐Chi, and Peter Jan Van Leeuwen. \"A particle flow filter for high‐dimensional system applications.\" Quarterly Journal of the Royal Meteorological Society 147.737 (2021): 2352-2374.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[11] Cleary, Emmet, et al. \"Calibrate, emulate, sample.\" Journal of Computational Physics 424 (2021): 109716.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[12] Goodman, Jonathan, and Jonathan Weare. \"Ensemble samplers with affine invariance.\" Communications in applied mathematics and computational science 5.1 (2010): 65-80.","category":"page"}]
}
